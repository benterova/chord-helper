import React, { useState, useRef, useEffect } from 'react';
import { audioEngine } from '../lib/audio';
import { type Chord, getChordMidiNotes, getChordNotes } from '../lib/theory';
import { CIRCLE_OF_FIFTHS, NOTES, MODE_DISPLAY_NAMES, type ScaleName } from '../lib/constants';
import { useMusicTheory } from '../lib/MusicTheoryContext';
import { ParticleSystem } from './ParticleSystem';
import { applySmartVoicing } from '../lib/voicing';
import { downloadGeneratedMidi } from '../lib/midi';
import type { MidiEvent } from '../lib/engine';
import { STYLES } from '../lib/engine';
import {
    DndContext,
    closestCenter,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
    type DragEndEvent
} from '@dnd-kit/core';
import {
    arrayMove,
    SortableContext,
    sortableKeyboardCoordinates,
    verticalListSortingStrategy,
    useSortable
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

// --- Sortable Item Component ---
const SortableChordItem = ({ id, chord, isActive }: { id: string, chord: Chord, isActive: boolean }) => {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging
    } = useSortable({ id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.5 : 1,
        touchAction: 'none' // Important for pointer events
    };

    return (
        <div
            ref={setNodeRef}
            style={{ ...style, display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '4px 8px', fontSize: '11px', cursor: 'grab' }}
            className={`aero-chord-item ${isActive ? 'active' : ''}`}
            {...attributes}
            {...listeners}
        >
            <span style={{ fontWeight: 'bold' }}>{chord.chordName}</span>
            <span style={{ fontSize: '9px', color: '#666' }}>{chord.roman}</span>
        </div>
    );
};
export const CircleOfFifths: React.FC = () => {
    const { root, mode, chords, setRoot, setMode } = useMusicTheory();

    // Frutiger Aero Palette - Vibrant, Glossy, Gel-like
    const QUALITY_COLORS: Record<string, string> = {
        'major': 'url(#grad-major)', // Cyan/Blue
        'minor': 'url(#grad-minor)', // Pink/Magenta
        'dim': 'url(#grad-dim)',   // Bright Green
        'aug': 'url(#grad-aug)',   // Purple
        'unknown': '#ccc'
    };

    const INACTIVE_COLOR = 'url(#grad-inactive)';

    const size = 500;
    const center = size / 2;
    const radius = 140;
    const angleStep = 360 / 12;
    const depth = 15;

    const [hoveredChord, setHoveredChord] = useState<Chord | null>(null);
    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
    const containerRef = useRef<HTMLDivElement>(null);

    // --- Interactive State ---
    const [customSequence, setCustomSequence] = useState<Chord[]>([]);
    const [isPlaying, setIsPlaying] = useState(false);
    const [playbackIndex, setPlaybackIndex] = useState<number | null>(null);
    const [isRecording, setIsRecording] = useState(false); // New: Recording Toggle
    const [suggestions, setSuggestions] = useState<string[]>([]); // Array of root notes

    // Options
    const [useSmartVoicing, setUseSmartVoicing] = useState(true);

    // --- DnD Sensors ---
    const sensors = useSensors(
        useSensor(PointerSensor, {
            activationConstraint: {
                distance: 5, // Require slight drag to activate, enabling clicks
            },
        }),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    );

    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event;

        if (active.id !== over?.id) {
            setCustomSequence((items) => {
                const oldIndex = items.findIndex((_, i) => `chord-${i}` === active.id);
                const newIndex = items.findIndex((_, i) => `chord-${i}` === over?.id);

                if (oldIndex !== -1 && newIndex !== -1) {
                    return arrayMove(items, oldIndex, newIndex);
                }
                return items;
            });
        }
    };

    // --- Suggestion Logic ---
    useEffect(() => {
        if (customSequence.length === 0) {
            setSuggestions([]);
            return;
        }

        const lastChord = customSequence[customSequence.length - 1];
        if (!lastChord) return;

        // Theory Logic:
        // 1. Neighbors on Circle (IV and V)
        // 2. Relative Minor/Major (same key signature, usually 3 steps away in chromatic... wait, in circle it's same position usually treated as relative? 
        //    No, relative minor is 3 semitones down. In Circle, relative minor/major often shares the same sector in some designs, but here we have unique roots.)

        const lastRootIndex = CIRCLE_OF_FIFTHS.indexOf(lastChord.root as any);
        if (lastRootIndex === -1) return;

        const nextIndex = (lastRootIndex + 1) % 12; // Dominant (V)
        const prevIndex = (lastRootIndex - 1 + 12) % 12; // Subdominant (IV)

        // Relative Minor of Major is vi. In C Major, A Minor.
        // A is 3 steps clockwise from C? C->G->D->A. Yes.
        const relativeIndex = (lastRootIndex + 3) % 12;

        const suggestedRoots = [
            CIRCLE_OF_FIFTHS[nextIndex],
            CIRCLE_OF_FIFTHS[prevIndex],
            CIRCLE_OF_FIFTHS[relativeIndex]
        ];

        setSuggestions(suggestedRoots);

    }, [customSequence]);

    const handleMouseMove = (e: React.MouseEvent) => {
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            setMousePos({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
        }
    };

    // --- Paths ---
    const createSectorPath = (cx: number, cy: number, r: number, startAngle: number, endAngle: number) => {
        const startRad = (startAngle * Math.PI) / 180;
        const endRad = (endAngle * Math.PI) / 180;
        const x1 = cx + r * Math.cos(startRad);
        const y1 = cy + r * Math.sin(startRad);
        const x2 = cx + r * Math.cos(endRad);
        const y2 = cy + r * Math.sin(endRad);
        return `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 0 1 ${x2} ${y2} Z`;
    };

    const createSidePath = (cx: number, cy: number, r: number, startAngle: number, endAngle: number, depth: number) => {
        const startRad = (startAngle * Math.PI) / 180;
        const endRad = (endAngle * Math.PI) / 180;
        const x1 = cx + r * Math.cos(startRad);
        const y1 = cy + r * Math.sin(startRad);
        const x2 = cx + r * Math.cos(endRad);
        const y2 = cy + r * Math.sin(endRad);
        return `M ${x1} ${y1} L ${x1} ${y1 + depth} A ${r} ${r} 0 0 1 ${x2} ${y2 + depth} L ${x2} ${y2} A ${r} ${r} 0 0 0 ${x1} ${y1} Z`;
    };

    // --- Actions ---
    const handleChordClick = (chord: Chord | undefined) => {
        if (!chord) return;

        // Play sound immediately (preview)
        // If Smart Voicing is on, we might want to voice it relative to the last chord in sequence?
        // For click preview, just raw notes is usually better feedback.
        const midiNotes = getChordMidiNotes(chord);
        audioEngine.playNotes(midiNotes, 0.5, true);

        // Add to sequence ONLY if Recording
        if (isRecording) {
            setCustomSequence(prev => [...prev, chord]);
        }
    };

    const handlePlaySequence = async () => {
        if (customSequence.length === 0) return;

        if (isPlaying) {
            audioEngine.stop();
            setIsPlaying(false);
            setPlaybackIndex(null);
            return;
        }

        setIsPlaying(true);

        const sequenceToPlay = useSmartVoicing
            ? applySmartVoicing(customSequence).map(vc => ({ notes: vc.notes, duration: 1.0 }))
            : customSequence.map(c => ({ notes: getChordMidiNotes(c), duration: 1.0 }));

        // Play Audio
        audioEngine.playProgression(sequenceToPlay, 'circle-custom');

        // Visual Sync
        let idx = 0;
        setPlaybackIndex(0);

        const interval = setInterval(() => {
            idx++;
            if (idx >= sequenceToPlay.length) {
                clearInterval(interval);
                setIsPlaying(false);
                setPlaybackIndex(null);
            } else {
                setPlaybackIndex(idx);
            }
        }, 1000); // 1.0s duration
    };

    const handleClear = () => {
        setCustomSequence([]);
        setPlaybackIndex(null);
        audioEngine.stop();
        setIsPlaying(false);
    };

    const handleRemoveLast = () => {
        setCustomSequence(prev => prev.slice(0, -1));
    };

    const handleDownload = () => {
        if (customSequence.length === 0) return;

        // Prepare events
        const sequenceToExport = useSmartVoicing
            ? applySmartVoicing(customSequence)
            : customSequence.map(c => ({ chord: c, notes: getChordMidiNotes(c) }));

        // 120 BPM, 1000ms duration = 2 beats (let's say) -> 256 ticks?
        // Standard MIDI file logic in library might differ, but engine usually assumes ticks.
        // Let's assume standard quarter note = 128 ticks.
        // 1 second at 120bpm = 2 beats = 256 ticks.

        const events: MidiEvent[] = sequenceToExport.map((item, i) => ({
            notes: item.notes,
            startTime: i * 256,
            duration: 256,
            velocity: 90
        }));

        downloadGeneratedMidi('Custom_Circle_Seq', events, root, mode, STYLES.POP);
    };

    const standardModes: ScaleName[] = ['ionian', 'dorian', 'phrygian', 'lydian', 'mixolydian', 'natural_minor', 'locrian'];
    const otherScales: ScaleName[] = ['harmonic_minor', 'melodic_minor', 'major_pentatonic', 'minor_pentatonic', 'blues'];

    return (
        <div className="circle-section" ref={containerRef} onMouseMove={handleMouseMove} style={{ display: 'flex', flexDirection: 'row', height: '100%', background: 'transparent', fontFamily: '"Segoe UI", sans-serif', position: 'relative', overflow: 'hidden' }}>

            {/* --- LEFT SIDEBAR: Custom Sequence --- */}
            <div className="aero-sidebar" style={{
                width: '160px',
                display: 'flex',
                flexDirection: 'column',
                borderRight: '1px solid rgba(255,255,255,0.5)',
                background: 'linear-gradient(to right, rgba(240,250,255,0.7), rgba(255,255,255,0.3))',
                zIndex: 20,
                backdropFilter: 'blur(5px)',
                boxShadow: '5px 0 15px rgba(0,0,0,0.05)'
            }}>
                {/* Header / Rec Status */}
                <div style={{ padding: '8px', borderBottom: '1px solid rgba(255,255,255,0.5)', textAlign: 'center', fontSize: '11px', color: '#555', fontWeight: '600' }}>
                    {isRecording ? 'Recording...' : 'Sequence'}
                </div>

                {/* Progression List (Sortable) */}
                <div style={{ flex: 1, overflowY: 'auto', padding: '5px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    <DndContext
                        sensors={sensors}
                        collisionDetection={closestCenter}
                        onDragEnd={handleDragEnd}
                    >
                        <SortableContext
                            items={customSequence.map((_, i) => `chord-${i}`)}
                            strategy={verticalListSortingStrategy}
                        >
                            {customSequence.length === 0 ? (
                                <div style={{ textAlign: 'center', padding: '10px', color: '#8899aa', fontSize: '10px', fontStyle: 'italic', border: '1px dashed rgba(0,0,0,0.1)', borderRadius: '6px', marginTop: '10px' }}>
                                    Empty
                                </div>
                            ) : (
                                customSequence.map((c, i) => (
                                    <SortableChordItem
                                        key={`chord-${i}`}
                                        id={`chord-${i}`}
                                        chord={c}
                                        isActive={i === playbackIndex}
                                    />
                                ))
                            )}
                        </SortableContext>
                    </DndContext>
                </div>

                {/* Bottom Actions */}
                <div style={{ padding: '8px', borderTop: '1px solid rgba(255,255,255,0.5)', display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '4px' }}>
                    <button
                        className={`silver-btn silver-btn-small ${isRecording ? 'active' : ''}`}
                        onClick={() => setIsRecording(!isRecording)}
                        title="Toggle Record Mode"
                        style={{
                            padding: '2px',
                            border: isRecording ? '1px solid #ff0000' : undefined,
                            color: isRecording ? '#cc0000' : undefined,
                            boxShadow: isRecording ? '0 0 5px rgba(255,0,0,0.4), inset 0 1px 0 #fff' : undefined,
                            fontWeight: 'bold'
                        }}>
                        {isRecording ? '‚óè' : '‚óã'}
                    </button>
                    <button className="silver-btn silver-btn-small" onClick={handlePlaySequence} title="Play" style={{ padding: '2px' }}>
                        {isPlaying ? '‚ñ†' : '‚ñ∂'}
                    </button>
                    <button className="silver-btn silver-btn-small" onClick={handleRemoveLast} title="Undo" style={{ padding: '2px' }}>
                        ‚Ü∂
                    </button>
                    <button className="silver-btn silver-btn-small" onClick={handleClear} title="Clear" style={{ padding: '2px' }}>
                        üóë
                    </button>
                    <button className="silver-btn silver-btn-small" onClick={handleDownload} title="MIDI" style={{ padding: '2px' }}>
                        ‚¨á
                    </button>
                </div>
            </div>

            {/* --- MAIN AREA: Circle & Top Controls --- */}
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', position: 'relative', overflow: 'hidden' }}>

                {/* Top Control Bar */}
                <div style={{
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    gap: '15px',
                    padding: '8px',
                    background: 'linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0.4))',
                    borderBottom: '1px solid rgba(255,255,255,0.6)',
                    zIndex: 10
                }}>
                    {/* Key */}
                    <select
                        value={root}
                        onChange={(e) => setRoot(e.target.value)}
                        className="aero-select"
                        style={{ width: '60px' }}
                    >
                        {NOTES.map(note => (
                            <option key={note} value={note}>{note}</option>
                        ))}
                    </select>

                    {/* Scale */}
                    <select
                        value={mode}
                        onChange={(e) => setMode(e.target.value as ScaleName)}
                        className="aero-select"
                        style={{ width: '120px' }}
                    >
                        <optgroup label="Standard Modes">
                            {standardModes.map(m => (
                                <option key={m} value={m}>{MODE_DISPLAY_NAMES[m]}</option>
                            ))}
                        </optgroup>
                        <optgroup label="Other Scales">
                            {otherScales.map(m => (
                                <option key={m} value={m}>{MODE_DISPLAY_NAMES[m]}</option>
                            ))}
                        </optgroup>
                    </select>

                    {/* Smart Voicing Toggle */}
                    <label style={{
                        display: 'flex', alignItems: 'center', gap: '6px',
                        fontSize: '11px', fontWeight: '600', color: '#004466',
                        background: 'rgba(255,255,255,0.5)', padding: '4px 8px', borderRadius: '12px',
                        border: '1px solid rgba(255,255,255,0.8)', cursor: 'pointer'
                    }}>
                        <input type="checkbox" checked={useSmartVoicing} onChange={(e) => setUseSmartVoicing(e.target.checked)} />
                        Smart Voice Leading
                    </label>
                </div>

                {/* Chart Area */}
                <div style={{ position: 'relative', width: '100%', flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }}>

                    {/* Visualizer / Particle System Background */}
                    <ParticleSystem
                        active={isPlaying || hoveredChord !== null}
                        width={size}
                        height={size}
                        intensity={isPlaying ? 'high' : 'low'}
                        color={isPlaying ? "rgba(0, 255, 255, " : undefined} // Dynamic color?
                        style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%,-50%)', opacity: 0.6 }}
                    />

                    <svg viewBox={`0 0 ${size} ${size}`} style={{ width: '100%', height: '100%', maxHeight: '420px', filter: 'drop-shadow(0 15px 25px rgba(0,160,255,0.3))' }}>
                        <defs>
                            {/* Frutiger Aero Gradients - Enhanced */}
                            <linearGradient id="grad-major" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#4facfe" />
                                <stop offset="50%" stopColor="#00f2fe" />
                                <stop offset="100%" stopColor="#4facfe" />
                            </linearGradient>
                            <linearGradient id="grad-minor" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#fa709a" />
                                <stop offset="50%" stopColor="#fee140" />
                                <stop offset="100%" stopColor="#fa709a" />
                            </linearGradient>
                            <linearGradient id="grad-dim" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#43e97b" />
                                <stop offset="50%" stopColor="#38f9d7" />
                                <stop offset="100%" stopColor="#43e97b" />
                            </linearGradient>
                            <linearGradient id="grad-aug" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#a18cd1" />
                                <stop offset="50%" stopColor="#fbc2eb" />
                                <stop offset="100%" stopColor="#a18cd1" />
                            </linearGradient>
                            <linearGradient id="grad-inactive" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="#e0e0e0" />
                                <stop offset="50%" stopColor="#ffffff" />
                                <stop offset="100%" stopColor="#e0e0e0" />
                            </linearGradient>

                            {/* Glossy Overlay - "Gel" Look */}
                            <linearGradient id="gel-shine" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" stopColor="rgba(255,255,255,0.9)" />
                                <stop offset="10%" stopColor="rgba(255,255,255,0.4)" />
                                <stop offset="50%" stopColor="rgba(255,255,255,0)" />
                                <stop offset="100%" stopColor="rgba(255,255,255,0.2)" />
                            </linearGradient>
                        </defs>

                        <g transform={`translate(${center}, ${center}) rotate(-90)`}> {/* Rotate so C is top */}
                            {/* Render Slices */}
                            {CIRCLE_OF_FIFTHS.map((note, index) => {
                                const chordData = chords.find(c => c.root === note);
                                const isHovered = hoveredChord?.root === note;
                                const isActive = root === note;
                                const isPlayingChord = playbackIndex !== null && customSequence[playbackIndex]?.root === note;

                                const isSuggested = !isPlaying && suggestions.includes(note); // Suggest if valid chord exists

                                // Pull out logic: Only on hover or playing
                                const pullOut = isHovered || isPlayingChord ? 25 : (isActive ? 10 : 0);
                                const midAngle = (index * angleStep);
                                const rad = midAngle * Math.PI / 180;
                                const tx = pullOut * Math.cos(rad);
                                const ty = pullOut * Math.sin(rad);

                                const startAngle = (index * angleStep) - (angleStep / 2) + 1; // Gap
                                const endAngle = startAngle + angleStep - 2; // Gap

                                // Determine Color
                                let fill = INACTIVE_COLOR;
                                if (chordData) {
                                    fill = QUALITY_COLORS[chordData.quality] || QUALITY_COLORS['unknown'];
                                }

                                return (
                                    <g key={note}
                                        transform={`translate(${tx}, ${ty})`}
                                        onMouseEnter={() => chordData && setHoveredChord(chordData)}
                                        onMouseLeave={() => setHoveredChord(null)}
                                        onClick={() => handleChordClick(chordData)}
                                        style={{ cursor: chordData ? 'pointer' : 'default', transition: 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)' }}
                                    >
                                        {/* 3D Side (Depth) */}
                                        <path
                                            d={createSidePath(0, 0, radius, startAngle, endAngle, depth)}
                                            fill="rgba(0,0,0,0.15)"
                                            stroke="none"
                                        />

                                        {/* Glow for Suggested */}
                                        {isSuggested && (
                                            <path
                                                d={createSectorPath(0, 0, radius + 4, startAngle, endAngle)}
                                                fill="none"
                                                stroke="#00ffff"
                                                strokeWidth="4"
                                                filter="blur(4px)"
                                                opacity="0.8"
                                            >
                                                <animate attributeName="opacity" values="0.8;0.3;0.8" dur="1.5s" repeatCount="indefinite" />
                                            </path>
                                        )}

                                        {/* Main Face */}
                                        <path
                                            d={createSectorPath(0, 0, radius, startAngle, endAngle)}
                                            fill={fill}
                                            fillOpacity={isActive || isHovered || chordData ? 0.95 : 0.4}
                                            stroke={isSuggested ? "#ccffff" : "rgba(255,255,255,0.6)"}
                                            strokeWidth={isSuggested ? "3" : "1"}
                                        />

                                        {/* Gel Shine */}
                                        <path
                                            d={createSectorPath(0, 0, radius * 0.9, startAngle, endAngle)}
                                            fill="url(#gel-shine)"
                                            pointerEvents="none"
                                            opacity="0.6"
                                        />

                                        {/* Active Dot */}
                                        {(isActive || isPlayingChord) && (
                                            <circle cx={(radius - 20) * Math.cos(rad)} cy={(radius - 20) * Math.sin(rad)} r="5" fill="#fff" filter="drop-shadow(0 0 5px #fff)" />
                                        )}
                                    </g>
                                );
                            })}
                        </g>

                        {/* Leader Lines & Labels layer */}
                        <g transform={`translate(${center}, ${center})`}>
                            {CIRCLE_OF_FIFTHS.map((note, index) => {
                                const chordData = chords.find(c => c.root === note);
                                const isActive = root === note;
                                const isPlayingChord = playbackIndex !== null && customSequence[playbackIndex]?.root === note;

                                const angle = (index * angleStep) - 90;
                                const rad = angle * Math.PI / 180;

                                const rLabel = radius + 35;
                                const x = rLabel * Math.cos(rad);
                                const y = rLabel * Math.sin(rad);

                                const rAnchor = radius + 5;
                                const ax = rAnchor * Math.cos(rad);
                                const ay = rAnchor * Math.sin(rad);

                                const labelText = chordData ? `${note}` : note;
                                const subText = chordData ? `(${chordData.roman})` : '';

                                const labelColor = (isActive || isPlayingChord) ? '#0077aa' : (chordData ? '#004466' : 'rgba(0,68,102,0.3)');
                                const fontWeight = (isActive || isPlayingChord) ? '800' : (chordData ? '600' : '400');
                                const fontSize = (isActive || isPlayingChord) ? '20' : '16';

                                return (
                                    <g key={`label-${note}`} style={{ transition: 'all 0.3s ease' }}>
                                        {chordData && (
                                            <polyline
                                                points={`${ax},${ay} ${x * 0.85},${y * 0.85}`}
                                                fill="none"
                                                stroke={(isActive || isPlayingChord) ? "#00aeff" : "rgba(0,174,255,0.3)"}
                                                strokeWidth={(isActive || isPlayingChord) ? "2" : "1"}
                                            />
                                        )}
                                        <text
                                            x={x}
                                            y={y}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            fontSize={fontSize}
                                            fontWeight={fontWeight}
                                            fill={labelColor}
                                            style={{ textShadow: (isActive || isPlayingChord) ? '0 0 10px rgba(255,255,255,0.8)' : 'none' }}
                                        >
                                            {labelText}
                                            <tspan x={x} dy="16" fontSize="11" fill={(isActive || isPlayingChord) ? '#0077aa' : '#888'} fontWeight="normal">{subText}</tspan>
                                        </text>
                                    </g>
                                );
                            })}
                        </g>

                        {/* Central Hub Bubble - Frutiger Aero Gem */}
                        <g transform={`translate(${center}, ${center})`}>
                            {/* Outer Glow */}
                            <circle r="48" fill="url(#grad-major)" opacity="0.3" filter="blur(8px)" />

                            {/* Main Body with Gradient */}
                            <circle r="42" fill="url(#grad-major)" stroke="rgba(255,255,255,0.9)" strokeWidth="1.5" />

                            {/* Inner Depth Shadow */}
                            <circle r="42" fill="url(#grad-minor)" opacity="0.1" />

                            {/* Crisp Highlight Reflection (Top) */}
                            <path d="M -30 -15 Q 0 -38 30 -15 Q 0 -25 -30 -15 Z" fill="rgba(255,255,255,0.7)" filter="blur(1px)" />

                            {/* Gel Shine Overlay (Bottom) */}
                            <path d="M -35 15 Q 0 45 35 15 Q 0 30 -35 15 Z" fill="rgba(255,255,255,0.4)" />

                            {/* Text */}
                            <text y="-8" textAnchor="middle" fontSize="9" fill="rgba(255,255,255,0.9)" fontWeight="bold" letterSpacing="1" style={{ textShadow: '0 1px 2px rgba(0,0,0,0.3)' }}>KEY</text>
                            <text y="16" textAnchor="middle" fontSize="22" fill="#fff" fontWeight="800" style={{ textShadow: '0 2px 4px rgba(0,0,0,0.2)' }}>{root}</text>
                        </g>
                    </svg>
                </div>

                {/* Legend - Bottom Right of Main Area */}
                <div className="aero-legend" style={{ position: 'absolute', bottom: '10px', right: '10px' }}>
                    <div className="legend-item">
                        <div className="legend-dot dot-major"></div>
                        <span>Major</span>
                    </div>
                    <div className="legend-item">
                        <div className="legend-dot dot-minor"></div>
                        <span>Minor</span>
                    </div>
                    <div className="legend-item">
                        <div className="legend-dot dot-dim"></div>
                        <span>Dim</span>
                    </div>
                </div>
            </div>

            {/* Sticky Note Tooltip - Now Aero Glass Popover */}
            {
                hoveredChord && (
                    <div style={{
                        position: 'absolute',
                        left: Math.min(mousePos.x + 20, window.innerWidth - 160), // Clamp inside
                        top: Math.min(mousePos.y - 20, window.innerHeight - 100),
                        width: '140px',
                        background: 'rgba(255, 255, 255, 0.8)',
                        backdropFilter: 'blur(8px)',
                        border: '1px solid rgba(255, 255, 255, 0.9)',
                        boxShadow: '0 5px 15px rgba(0, 0, 0, 0.1), inset 0 0 10px rgba(255,255,255,0.5)',
                        padding: '8px',
                        borderRadius: '8px',
                        pointerEvents: 'none',
                        zIndex: 100,
                        fontFamily: '"Segoe UI", sans-serif',
                        color: '#004466',
                        transform: 'translateY(-100%)' // Tooltip above mouse
                    }}>
                        {/* Header */}
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'baseline',
                            borderBottom: '1px solid rgba(0, 100, 200, 0.1)',
                            paddingBottom: '2px',
                            marginBottom: '4px'
                        }}>
                            <div style={{ fontSize: '0.9rem', fontWeight: 'bold', color: '#005577' }}>
                                {hoveredChord.chordName}
                            </div>
                            <div style={{ fontSize: '0.8rem', color: '#0088cc', fontWeight: '600' }}>
                                {hoveredChord.roman}
                            </div>
                        </div>

                        {/* Content */}
                        <div style={{ fontSize: '0.75rem', color: '#666', marginBottom: '2px' }}>
                            {getChordNotes(hoveredChord).join(' - ')}
                        </div>
                        <div style={{ fontSize: '0.7rem', color: '#aaa', fontStyle: 'italic' }}>
                            {isRecording ? 'Click to Add' : 'Click to Play'}
                        </div>
                    </div>
                )
            }
        </div >
    );
};
